@page "/grammar"
@page "/parse"
@using DSLKIT.Ast
@using DSLKIT.Lexer
@using DSLKIT.Parser
@using DSLKIT.Terminals
@using DSLKIT.Tokens
@inject IGrammarProviderCatalog ProviderCatalog
@inject IGrammarProviderAssemblyLoader AssemblyLoader
@inject IGrammarSnapshotMapper SnapshotMapper
@inject IJSRuntime JS

<PageTitle>Grammar Workspace</PageTitle>

<div class="dsl-grammar-page">
    <MudText Typo="Typo.h4">Grammar Workspace</MudText>

    <MudPaper Class="dsl-control-panel mt-3 pa-3" Elevation="1">
        <div class="dsl-control-row">
            <div class="dsl-control-field">
                <label class="form-label mb-1" for="grammar-provider-select">Grammar</label>
                <select id="grammar-provider-select"
                        class="form-select"
                        value="@selectedProviderId"
                        @onchange="OnSelectedProviderChangedAsync"
                        disabled="@(_providerOptions.Count == 0)">
                    @if (_providerOptions.Count == 0)
                    {
                        <option value="">No providers</option>
                    }
                    else
                    {
                        @foreach (var provider in _providerOptions)
                        {
                            <option value="@provider.Id">@provider.DisplayName (@provider.Id)</option>
                        }
                    }
                </select>
            </div>

            <div class="dsl-control-actions">
                <InputFile id="provider-dll-input"
                           class="d-none"
                           OnChange="LoadAssembliesAsync"
                           accept=".dll" />
                <label class="btn btn-outline-secondary mb-0" for="provider-dll-input">Upload DLL</label>

                <button class="btn btn-primary d-flex align-items-center gap-2"
                        @onclick="RunParseAsync"
                        disabled="@(loadedGrammar == null || isParsing)">
                    @if (isParsing)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        <span>Parsing...</span>
                    }
                    else
                    {
                        <span>Parse</span>
                    }
                </button>
            </div>
        </div>

        @if (selectedProvider != null)
        {
            <div class="dsl-provider-meta mt-3">
                <div><span class="dsl-provider-meta-label">Name:</span> @selectedProvider.DisplayName (@selectedProvider.Id)</div>
                <div class="text-muted"><span class="dsl-provider-meta-label">Description:</span> @GetProviderDescription()</div>
                @if (!string.IsNullOrWhiteSpace(selectedProvider.DocumentationUrl))
                {
                    <div>
                        <span class="dsl-provider-meta-label">Article:</span>
                        <a href="@selectedProvider.DocumentationUrl"
                           target="_blank"
                           rel="noopener noreferrer">@selectedProvider.DocumentationUrl</a>
                    </div>
                }
            </div>
        }
    </MudPaper>

    @if (loadMessages.Count > 0)
    {
        <div class="alert alert-secondary mt-3" role="alert">
            @foreach (var message in loadMessages)
            {
                <div>@message</div>
            }
        </div>
    }

    <div class="row g-3 mt-1 dsl-workspace">
        <div class="col-xl-5">
            <section class="card h-100 dsl-input-panel">
                <div class="card-header">Input</div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label" for="grammar-example-select">Example</label>
                        @if (selectedProvider == null)
                        {
                            <div class="text-muted">Select a grammar to load examples.</div>
                        }
                        else if (selectedProvider.Examples.Count == 0)
                        {
                            <div class="text-muted">This grammar does not provide built-in examples.</div>
                        }
                        else
                        {
                            <select id="grammar-example-select"
                                    class="form-select"
                                    value="@selectedExampleId"
                                    @onchange="OnSelectedExampleChangedAsync">
                                @foreach (var example in selectedProvider.Examples)
                                {
                                    <option value="@example.Id">@example.Name</option>
                                }
                            </select>

                            @if (selectedExample != null)
                            {
                                <div class="form-text">@selectedExample.Description</div>
                            }
                        }
                    </div>

                    <label class="form-label mb-1" for="source-input">Source Text</label>

                    <textarea id="source-input"
                              class="form-control dsl-source-editor"
                              rows="18"
                              spellcheck="false"
                              @bind="sourceText"
                              @bind:event="oninput"
                              @ref="sourceInputRef"></textarea>

                    <div class="form-text mt-2">Edit source, then run Parse to refresh AST, Parse Tree and Tokens.</div>
                </div>
            </section>
        </div>

        <div class="col-xl-7">
            <section class="card h-100 dsl-result-panel">
                <div class="card-header">Result</div>
                <div class="card-body">
                    @if (!string.IsNullOrWhiteSpace(loadErrorMessage))
                    {
                        <MudAlert Severity="Severity.Error" Class="mb-3">
                            @loadErrorMessage
                        </MudAlert>
                    }

                    @if (isParsing)
                    {
                        <div class="alert alert-info d-flex align-items-center gap-2" role="status">
                            <span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
                            <span>Parsing in progress...</span>
                        </div>
                    }
                    else if (!HasParseOutput && string.IsNullOrWhiteSpace(loadErrorMessage))
                    {
                        <div class="alert alert-light" role="status">
                            Enter source text and click Parse.
                        </div>
                    }

                    <MudTabs Rounded="true" Elevation="0" Class="dsl-result-tabs">
                        <MudTabPanel Text="AST">
                            @if (activeAstTreeRoot == null)
                            {
                                <div class="text-muted">Run parsing to see AST.</div>
                            }
                            else
                            {
                                <div class="d-flex align-items-center gap-2 mb-2">
                                    <span class="text-muted">View:</span>
                                    <button type="button" class="@GetAstViewButtonClass(technicalView: false)" @onclick="ShowAstSemanticView">Semantic</button>
                                    <button type="button" class="@GetAstViewButtonClass(technicalView: true)" @onclick="ShowAstTechnicalView">Technical</button>
                                </div>
                                <div class="d-flex align-items-center gap-3 mb-2 flex-wrap">
                                    <span class="text-muted">Nodes: @GetNodeCount(activeAstTreeRoot), depth: @GetMaxDepth(activeAstTreeRoot)</span>
                                    <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="ResetActiveAstTreeState">Reset Tree State</button>
                                </div>

                                <div class="row g-3">
                                    <div class="col-xxl-8">
                                        <TreeView Root="activeAstTreeRoot"
                                                  State="activeAstTreeState"
                                                  SelectedNodeChanged="OnActiveAstNodeSelectedAsync" />
                                    </div>

                                    <div class="col-xxl-4">
                                        <div class="card dsl-ast-inspector">
                                            <div class="card-header">AST Inspector</div>
                                            <div class="card-body">
                                                @if (activeSelectedAstNode == null)
                                                {
                                                    <div class="text-muted">Select a node.</div>
                                                }
                                                else
                                                {
                                                    <dl class="row mb-0">
                                                        <dt class="col-sm-4">Name</dt>
                                                        <dd class="col-sm-8">@activeSelectedAstNode.Label</dd>

                                                        <dt class="col-sm-4">Type</dt>
                                                        <dd class="col-sm-8">@GetNodeTypeLabel(activeSelectedAstNode)</dd>

                                                        <dt class="col-sm-4">Kind</dt>
                                                        <dd class="col-sm-8">@activeSelectedAstNode.Kind</dd>

                                                        <dt class="col-sm-4">Children</dt>
                                                        <dd class="col-sm-8">@activeSelectedAstNode.Children.Count</dd>

                                                        <dt class="col-sm-4">Span</dt>
                                                        <dd class="col-sm-8">@GetNodeSpanLabel(activeSelectedAstNode)</dd>

                                                        <dt class="col-sm-4">Preview</dt>
                                                        <dd class="col-sm-8">
                                                            <pre class="dsl-node-preview">@GetNodePreview(activeSelectedAstNode)</pre>
                                                        </dd>

                                                        @if (!string.IsNullOrWhiteSpace(activeSelectedAstNode.Description))
                                                        {
                                                            <dt class="col-sm-4">Description</dt>
                                                            <dd class="col-sm-8">
                                                                <div class="ast-node-description">@activeSelectedAstNode.Description</div>
                                                            </dd>
                                                        }
                                                    </dl>

                                                    @if (CanRevealInSource(activeSelectedAstNode))
                                                    {
                                                        <button type="button"
                                                                class="btn btn-outline-primary btn-sm mt-3"
                                                                @onclick="RevealActiveAstNodeInSourceAsync">Reveal in source</button>
                                                    }
                                                }
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            }
                        </MudTabPanel>

                        <MudTabPanel Text="Parse Tree">
                            @if (parseTreeRoot == null)
                            {
                                <div class="text-muted">Run parsing to see parse tree.</div>
                            }
                            else
                            {
                                <div class="d-flex align-items-center gap-3 mb-2 flex-wrap">
                                    <span class="text-muted">Nodes: @GetNodeCount(parseTreeRoot), depth: @GetMaxDepth(parseTreeRoot)</span>
                                    <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="ResetParseTreeState">Reset Tree State</button>
                                </div>
                                <TreeView Root="parseTreeRoot" State="parseTreeState" />
                            }
                        </MudTabPanel>

                        <MudTabPanel Text="Tokens">
                            @if (tokenRows.Count == 0)
                            {
                                <div class="text-muted">Run parsing to see tokens.</div>
                            }
                            else
                            {
                                <table class="table table-sm table-striped table-bordered">
                                    <thead>
                                        <tr>
                                            <th>#</th>
                                            <th>Kind</th>
                                            <th>Terminal</th>
                                            <th>Text</th>
                                            <th>Value</th>
                                            <th>Pos</th>
                                            <th>Len</th>
                                            <th>Ignored</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var token in tokenRows)
                                        {
                                            <tr>
                                                <td>@token.Index</td>
                                                <td>@token.Kind</td>
                                                <td>@token.Terminal</td>
                                                <td>@token.Text</td>
                                                <td>@token.Value</td>
                                                <td>@token.Position</td>
                                                <td>@token.Length</td>
                                                <td>@(token.IsIgnoredForParsing ? "yes" : string.Empty)</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            }
                        </MudTabPanel>

                        <MudTabPanel Text="Parsing Tables">
                            @if (snapshot == null)
                            {
                                <div class="text-muted">Select a grammar to load parsing tables.</div>
                            }
                            else
                            {
                                <MudPaper Class="mt-2 pa-4 dsl-summary-paper" Elevation="1">
                                    <MudText Typo="Typo.h6">@snapshot.GrammarName</MudText>

                                    <dl class="row mb-0 mt-3">
                                        <dt class="col-sm-3">Root</dt>
                                        <dd class="col-sm-9">@snapshot.RootName</dd>
                                        <dt class="col-sm-3">Terminals</dt>
                                        <dd class="col-sm-9">@snapshot.TerminalCount</dd>
                                        <dt class="col-sm-3">Non-terminals</dt>
                                        <dd class="col-sm-9">@snapshot.NonTerminalCount</dd>
                                        <dt class="col-sm-3">Productions</dt>
                                        <dd class="col-sm-9">@snapshot.Productions.Count</dd>
                                        <dt class="col-sm-3">Rule sets</dt>
                                        <dd class="col-sm-9">@snapshot.RuleSetCount</dd>
                                    </dl>
                                </MudPaper>

                                <MudExpansionPanels Class="mt-4" MultiExpansion="true">
                                    <MudExpansionPanel Text="Productions" Expanded="true">
                                        <div class="dsl-wide-table-container">
                                            <MudTable T="ProductionRowDto"
                                                      Items="snapshot.Productions"
                                                      Dense="true"
                                                      Hover="true"
                                                      Bordered="true"
                                                      Striped="true"
                                                      Breakpoint="Breakpoint.None"
                                                      Class="dsl-wide-table">
                                                <HeaderContent>
                                                    <MudTh>#</MudTh>
                                                    <MudTh>Left</MudTh>
                                                    <MudTh>Right</MudTh>
                                                </HeaderContent>
                                                <RowTemplate>
                                                    <MudTd DataLabel="#">@context.Number</MudTd>
                                                    <MudTd DataLabel="Left">@context.Left</MudTd>
                                                    <MudTd DataLabel="Right">@context.Right</MudTd>
                                                </RowTemplate>
                                            </MudTable>
                                        </div>
                                    </MudExpansionPanel>

                                    <MudExpansionPanel Text="@snapshot.TranslationTable.Name">
                                        <WideTable Table="snapshot.TranslationTable" />
                                    </MudExpansionPanel>

                                    <MudExpansionPanel Text="@snapshot.ActionAndGotoTable.Name">
                                        <WideTable Table="snapshot.ActionAndGotoTable" />
                                    </MudExpansionPanel>

                                    <MudExpansionPanel Text="@snapshot.FirstsTable.Name">
                                        <WideTable Table="snapshot.FirstsTable" />
                                    </MudExpansionPanel>

                                    <MudExpansionPanel Text="@snapshot.FollowsTable.Name">
                                        <WideTable Table="snapshot.FollowsTable" />
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                        </MudTabPanel>
                    </MudTabs>
                </div>
            </section>
        </div>
    </div>
</div>

@code {
    private IReadOnlyList<IDslGrammarProvider> _providerOptions = [];
    private string? selectedProviderId;
    private string? selectedExampleId;
    private string? selectedExampleProviderId;
    private IGrammar? loadedGrammar;
    private GrammarSnapshotDto? snapshot;
    private string sourceText = string.Empty;
    private string? loadErrorMessage;
    private IReadOnlyList<string> loadMessages = [];
    private IReadOnlyList<TokenRowDto> tokenRows = [];
    private TreeNodeViewModel? parseTreeRoot;
    private TreeNodeViewModel? astSemanticTreeRoot;
    private TreeNodeViewModel? astTechnicalTreeRoot;
    private TreeViewState parseTreeState = new();
    private TreeViewState astSemanticTreeState = new();
    private TreeViewState astTechnicalTreeState = new();
    private TreeNodeViewModel? selectedAstSemanticNode;
    private TreeNodeViewModel? selectedAstTechnicalNode;
    private ElementReference sourceInputRef;
    private bool isParsing;
    private bool showAstTechnicalView;

    private IDslGrammarProvider? selectedProvider =>
        string.IsNullOrWhiteSpace(selectedProviderId)
            ? null
            : ProviderCatalog.FindById(selectedProviderId);

    private DslGrammarExample? selectedExample =>
        selectedProvider?.Examples.FirstOrDefault(example => example.Id == selectedExampleId);

    private TreeNodeViewModel? activeAstTreeRoot => showAstTechnicalView
        ? astTechnicalTreeRoot
        : astSemanticTreeRoot;

    private TreeViewState activeAstTreeState => showAstTechnicalView
        ? astTechnicalTreeState
        : astSemanticTreeState;

    private TreeNodeViewModel? activeSelectedAstNode => showAstTechnicalView
        ? selectedAstTechnicalNode
        : selectedAstSemanticNode;

    private bool HasParseOutput =>
        tokenRows.Count > 0 ||
        parseTreeRoot != null ||
        astSemanticTreeRoot != null ||
        astTechnicalTreeRoot != null;

    protected override async Task OnInitializedAsync()
    {
        await RefreshProvidersAsync();
        await LoadSelectedGrammarAsync();
    }

    private async Task LoadAssembliesAsync(InputFileChangeEventArgs args)
    {
        var beforeProviderIds = ProviderCatalog.GetAll()
            .Select(provider => provider.Id)
            .ToHashSet(StringComparer.Ordinal);

        var files = args.GetMultipleFiles();
        var report = await AssemblyLoader.LoadProvidersAsync(files);
        loadMessages = BuildLoadMessages(report);

        await RefreshProvidersAsync();

        var addedProvider = _providerOptions.FirstOrDefault(provider => !beforeProviderIds.Contains(provider.Id));
        if (addedProvider != null)
        {
            selectedProviderId = addedProvider.Id;
        }

        await LoadSelectedGrammarAsync();
    }

    private Task OnSelectedProviderChangedAsync(ChangeEventArgs args)
    {
        selectedProviderId = args.Value?.ToString();
        return LoadSelectedGrammarAsync();
    }

    private Task OnSelectedExampleChangedAsync(ChangeEventArgs args)
    {
        selectedExampleId = args.Value?.ToString();

        if (selectedProvider == null)
        {
            return Task.CompletedTask;
        }

        var example = selectedProvider.Examples.FirstOrDefault(item => item.Id == selectedExampleId);
        if (example == null)
        {
            return Task.CompletedTask;
        }

        sourceText = example.SourceText;
        return Task.CompletedTask;
    }

    private async Task RunParseAsync()
    {
        if (isParsing)
        {
            return;
        }

        isParsing = true;
        await InvokeAsync(StateHasChanged);
        await Task.Yield();

        try
        {
            ClearParseOutput();

            if (loadedGrammar == null || string.IsNullOrWhiteSpace(selectedProviderId))
            {
                loadErrorMessage = "Select and load a grammar provider first.";
                return;
            }

            var provider = ProviderCatalog.FindById(selectedProviderId);
            if (provider == null)
            {
                loadErrorMessage = $"Provider '{selectedProviderId}' is not registered.";
                return;
            }

            loadErrorMessage = null;

            var lexerSettings = provider.CreateLexerSettings(loadedGrammar);
            var lexer = new Lexer(lexerSettings);

            var allTokens = lexer.GetTokens(new StringSourceStream(sourceText)).ToList();
            tokenRows = MapTokenRows(allTokens);

            var lexerError = allTokens.OfType<ErrorToken>().FirstOrDefault();
            if (lexerError != null)
            {
                loadErrorMessage = lexerError.ToString();
                return;
            }

            var syntaxTokens = allTokens
                .Where(token => token.Terminal.Flags != TermFlags.Space && token.Terminal.Flags != TermFlags.Comment)
                .ToList();

            var parser = new SyntaxParser(loadedGrammar);
            var parseResult = parser.Parse(syntaxTokens);
            if (!parseResult.IsSuccess || parseResult.ParseTree == null)
            {
                loadErrorMessage = parseResult.Error?.ToString() ?? "Parse failed.";
                return;
            }

            parseTreeRoot = MapParseTreeNode(parseResult.ParseTree, "parse:0", sourceText);
            parseTreeState = new TreeViewState();

            var astRoot = new AstBuilder(loadedGrammar.AstBindings).Build(parseResult.ParseTree, sourceText);
            astSemanticTreeRoot = MapAstNodeSemantic(astRoot, "ast:semantic:0", sourceText, isRoot: true);
            astTechnicalTreeRoot = MapAstNodeTechnical(astRoot, "ast:technical:0", sourceText);
            astSemanticTreeState = new TreeViewState();
            astTechnicalTreeState = new TreeViewState();
            selectedAstSemanticNode = astSemanticTreeRoot;
            selectedAstTechnicalNode = astTechnicalTreeRoot;
            showAstTechnicalView = false;
        }
        catch (Exception ex)
        {
            loadErrorMessage = $"Unexpected error: {ex.Message}";
        }
        finally
        {
            isParsing = false;
        }
    }

    private async Task RevealActiveAstNodeInSourceAsync()
    {
        if (!TryGetNodeSpan(activeSelectedAstNode, out var spanStart, out var spanEnd))
        {
            return;
        }

        await JS.InvokeVoidAsync("dslkitSourceEditor.revealSelection", sourceInputRef, spanStart, spanEnd);
    }

    private async Task RefreshProvidersAsync()
    {
        _providerOptions = ProviderCatalog.GetAll();

        var nextProviderId = ResolveSelectedProviderId();
        if (string.Equals(selectedProviderId, nextProviderId, StringComparison.Ordinal))
        {
            return;
        }

        selectedProviderId = nextProviderId;
        await Task.CompletedTask;
    }

    private async Task LoadSelectedGrammarAsync()
    {
        loadedGrammar = null;
        snapshot = null;
        loadErrorMessage = null;
        ClearParseOutput();

        if (string.IsNullOrWhiteSpace(selectedProviderId))
        {
            selectedExampleId = null;
            selectedExampleProviderId = null;
            loadErrorMessage = "Select a grammar provider.";
            return;
        }

        var provider = ProviderCatalog.FindById(selectedProviderId);
        if (provider == null)
        {
            selectedExampleId = null;
            selectedExampleProviderId = null;
            loadErrorMessage = $"Provider '{selectedProviderId}' is not registered.";
            return;
        }

        EnsureExampleSelection(provider);

        try
        {
            loadedGrammar = provider.BuildGrammar();
            snapshot = SnapshotMapper.Map(loadedGrammar);
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            loadErrorMessage = $"Failed to load grammar: {ex.Message}";
        }
    }

    private string GetProviderDescription()
    {
        if (selectedProvider == null || string.IsNullOrWhiteSpace(selectedProvider.Description))
        {
            return "No description available.";
        }

        return selectedProvider.Description;
    }

    private void EnsureExampleSelection(IDslGrammarProvider provider)
    {
        if (!string.Equals(selectedExampleProviderId, provider.Id, StringComparison.Ordinal))
        {
            selectedExampleProviderId = provider.Id;
            SelectDefaultExample(provider);
            return;
        }

        if (provider.Examples.Count == 0)
        {
            selectedExampleId = null;
            return;
        }

        if (string.IsNullOrWhiteSpace(selectedExampleId) ||
            provider.Examples.All(example => example.Id != selectedExampleId))
        {
            SelectExample(provider.Examples[0]);
        }
    }

    private void SelectDefaultExample(IDslGrammarProvider provider)
    {
        if (provider.Examples.Count == 0)
        {
            selectedExampleId = null;
            sourceText = string.Empty;
            return;
        }

        SelectExample(provider.Examples[0]);
    }

    private void SelectExample(DslGrammarExample example)
    {
        selectedExampleId = example.Id;
        sourceText = example.SourceText;
    }

    private void ClearParseOutput()
    {
        tokenRows = [];
        parseTreeRoot = null;
        astSemanticTreeRoot = null;
        astTechnicalTreeRoot = null;
        parseTreeState = new TreeViewState();
        astSemanticTreeState = new TreeViewState();
        astTechnicalTreeState = new TreeViewState();
        selectedAstSemanticNode = null;
        selectedAstTechnicalNode = null;
        showAstTechnicalView = false;
    }

    private static IReadOnlyList<string> BuildLoadMessages(AssemblyLoadReport report)
    {
        var messages = new List<string>
        {
            $"Selected files: {report.SelectedFileCount}. Processed assemblies: {report.ProcessedAssemblyFileCount}. Registered providers: {report.RegisteredProviderCount}."
        };
        messages.AddRange(report.Messages);
        return messages;
    }

    private string? ResolveSelectedProviderId()
    {
        if (!string.IsNullOrWhiteSpace(selectedProviderId) &&
            _providerOptions.Any(provider => provider.Id == selectedProviderId))
        {
            return selectedProviderId;
        }

        return _providerOptions.FirstOrDefault()?.Id;
    }

    private static IReadOnlyList<TokenRowDto> MapTokenRows(IReadOnlyList<IToken> tokens)
    {
        return tokens
            .Select((token, index) => new TokenRowDto
            {
                Index = index,
                Kind = token.GetType().Name,
                Terminal = token is ErrorToken ? "LexerError" : token.Terminal.Name,
                Text = token.OriginalString ?? string.Empty,
                Value = token.Value?.ToString() ?? string.Empty,
                Position = token.Position,
                Length = token.Length,
                IsIgnoredForParsing = token is not ErrorToken &&
                                     (token.Terminal.Flags == TermFlags.Space ||
                                      token.Terminal.Flags == TermFlags.Comment)
            })
            .ToList();
    }

    private static TreeNodeViewModel MapParseTreeNode(ParseTreeNode node, string nodeId, string source)
    {
        var (label, kind) = node switch
        {
            NonTerminalNode nonTerminalNode => ($"NT: {nonTerminalNode.NonTerminal.Name}", TreeNodeKind.ParseNonTerminal),
            TerminalNode terminalNode => ($"T: {terminalNode.Token.Terminal.Name} '{terminalNode.Token.OriginalString}'", TreeNodeKind.ParseTerminal),
            _ => (node.Term.Name, TreeNodeKind.ParseNode)
        };

        var children = node.Children
            .Select((child, index) => MapParseTreeNode(child, $"{nodeId}/{index}", source))
            .ToList();

        var span = ResolveParseTreeSpan(node);

        return new TreeNodeViewModel
        {
            NodeId = nodeId,
            Label = label,
            Kind = kind,
            TypeName = node.GetType().Name,
            SpanStart = span?.Start,
            SpanEnd = span?.End,
            SourcePreview = BuildSourcePreview(source, span),
            Children = children
        };
    }

    private static TreeNodeViewModel MapAstNodeTechnical(IAstNode node, string nodeId, string source)
    {
        var children = node.Children
            .Select((child, index) => MapAstNodeTechnical(child, $"{nodeId}/{index}", source))
            .ToList();

        var span = ResolveAstNodeSpan(node);

        return new TreeNodeViewModel
        {
            NodeId = nodeId,
            Label = GetTechnicalAstLabel(node),
            Kind = node is AstTokenNode ? TreeNodeKind.AstToken : TreeNodeKind.AstNode,
            Description = GetTechnicalAstDescription(node),
            TypeName = node.GetType().Name,
            SpanStart = span?.Start,
            SpanEnd = span?.End,
            SourcePreview = BuildSourcePreview(source, span),
            Children = children
        };
    }

    private static string GetTechnicalAstLabel(IAstNode node)
    {
        if (node is AstTokenNode tokenNode)
        {
            return $"Token: {tokenNode.TerminalName} '{tokenNode.Text}'";
        }

        if (node is AstNodeBase astNodeBase)
        {
            return $"{node.GetType().Name} ({astNodeBase.ParseNode.Term.Name})";
        }

        return node.GetType().Name;
    }

    private static string? GetTechnicalAstDescription(IAstNode node)
    {
        if (node is AstTokenNode tokenNode)
        {
            return $"Terminal: {tokenNode.TerminalName}; Value: {tokenNode.Value}";
        }

        if (node is AstNodeBase astNodeBase)
        {
            return $"Parse term: {astNodeBase.ParseNode.Term.Name}";
        }

        return null;
    }

    private static TreeNodeViewModel MapAstNodeSemantic(IAstNode node, string nodeId, string source, bool isRoot)
    {
        var children = node.ChildrenDisplayMode == AstChildrenDisplayMode.Hide
            ? []
            : node.Children
                .Select((child, index) => MapAstNodeSemantic(child, $"{nodeId}/{index}", source, isRoot: false))
                .ToList();

        var span = ResolveAstNodeSpan(node);

        return new TreeNodeViewModel
        {
            NodeId = nodeId,
            Label = BuildSemanticAstLabel(node),
            Kind = ResolveSemanticAstNodeKind(node, isRoot, hasChildren: children.Count > 0),
            Description = NormalizeDescription(node.Description),
            TypeName = node.GetType().Name,
            SpanStart = span?.Start,
            SpanEnd = span?.End,
            SourcePreview = BuildSourcePreview(source, span),
            Children = children
        };
    }

    private static string BuildSemanticAstLabel(IAstNode node)
    {
        return string.IsNullOrWhiteSpace(node.DisplayName)
            ? node.GetType().Name
            : node.DisplayName;
    }

    private static string? NormalizeDescription(string? description)
    {
        if (string.IsNullOrWhiteSpace(description))
        {
            return null;
        }

        return string.Join(" ",
            description
                .Split(new[] { '\r', '\n', '\t' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(part => part.Trim()));
    }

    private static TreeNodeKind ResolveSemanticAstNodeKind(IAstNode node, bool isRoot, bool hasChildren)
    {
        if (isRoot)
        {
            return TreeNodeKind.AstSemanticRoot;
        }

        var nodeTypeName = node.GetType().Name;
        if (nodeTypeName.Contains("Section", StringComparison.OrdinalIgnoreCase))
        {
            return TreeNodeKind.AstSemanticSection;
        }

        if (nodeTypeName.Contains("Property", StringComparison.OrdinalIgnoreCase))
        {
            return TreeNodeKind.AstSemanticProperty;
        }

        if (!hasChildren || node.ChildrenDisplayMode == AstChildrenDisplayMode.Hide)
        {
            return TreeNodeKind.AstSemanticField;
        }

        return TreeNodeKind.AstNode;
    }

    private static int GetNodeCount(TreeNodeViewModel root)
    {
        return EnumerateNodes(root).Count();
    }

    private static int GetMaxDepth(TreeNodeViewModel root)
    {
        return GetMaxDepthCore(root, 1);
    }

    private static int GetMaxDepthCore(TreeNodeViewModel node, int depth)
    {
        if (node.Children.Count == 0)
        {
            return depth;
        }

        return node.Children.Max(child => GetMaxDepthCore(child, depth + 1));
    }

    private static IEnumerable<TreeNodeViewModel> EnumerateNodes(TreeNodeViewModel node)
    {
        yield return node;

        foreach (var child in node.Children)
        {
            foreach (var descendant in EnumerateNodes(child))
            {
                yield return descendant;
            }
        }
    }

    private void ResetParseTreeState()
    {
        parseTreeState = new TreeViewState();
    }

    private void ResetActiveAstTreeState()
    {
        if (showAstTechnicalView)
        {
            astTechnicalTreeState = new TreeViewState();
            selectedAstTechnicalNode = astTechnicalTreeRoot;
            return;
        }

        astSemanticTreeState = new TreeViewState();
        selectedAstSemanticNode = astSemanticTreeRoot;
    }

    private Task OnActiveAstNodeSelectedAsync(TreeNodeViewModel node)
    {
        if (showAstTechnicalView)
        {
            selectedAstTechnicalNode = node;
            return Task.CompletedTask;
        }

        selectedAstSemanticNode = node;
        return Task.CompletedTask;
    }

    private void ShowAstSemanticView()
    {
        showAstTechnicalView = false;
        if (selectedAstSemanticNode == null)
        {
            selectedAstSemanticNode = ResolveSelectedNode(astSemanticTreeRoot, astSemanticTreeState.SelectedNodeId)
                ?? astSemanticTreeRoot;
        }
    }

    private void ShowAstTechnicalView()
    {
        showAstTechnicalView = true;
        if (selectedAstTechnicalNode == null)
        {
            selectedAstTechnicalNode = ResolveSelectedNode(astTechnicalTreeRoot, astTechnicalTreeState.SelectedNodeId)
                ?? astTechnicalTreeRoot;
        }
    }

    private string GetAstViewButtonClass(bool technicalView)
    {
        var isActive = showAstTechnicalView == technicalView;
        return isActive
            ? "btn btn-sm btn-primary"
            : "btn btn-sm btn-outline-primary";
    }

    private static TreeNodeViewModel? ResolveSelectedNode(TreeNodeViewModel? root, string? nodeId)
    {
        if (root == null)
        {
            return null;
        }

        if (string.IsNullOrWhiteSpace(nodeId))
        {
            return root;
        }

        return FindNodeById(root, nodeId) ?? root;
    }

    private static TreeNodeViewModel? FindNodeById(TreeNodeViewModel node, string nodeId)
    {
        if (string.Equals(node.NodeId, nodeId, StringComparison.Ordinal))
        {
            return node;
        }

        foreach (var child in node.Children)
        {
            var foundNode = FindNodeById(child, nodeId);
            if (foundNode != null)
            {
                return foundNode;
            }
        }

        return null;
    }

    private static string GetNodeTypeLabel(TreeNodeViewModel node)
    {
        return string.IsNullOrWhiteSpace(node.TypeName)
            ? "n/a"
            : node.TypeName;
    }

    private static string GetNodeSpanLabel(TreeNodeViewModel? node)
    {
        if (!TryGetNodeSpan(node, out var spanStart, out var spanEnd))
        {
            return "n/a";
        }

        return $"{spanStart}..{spanEnd}";
    }

    private static string GetNodePreview(TreeNodeViewModel? node)
    {
        if (string.IsNullOrWhiteSpace(node?.SourcePreview))
        {
            return "n/a";
        }

        return node.SourcePreview;
    }

    private static bool CanRevealInSource(TreeNodeViewModel? node)
    {
        return TryGetNodeSpan(node, out _, out _);
    }

    private static bool TryGetNodeSpan(TreeNodeViewModel? node, out int spanStart, out int spanEnd)
    {
        spanStart = 0;
        spanEnd = 0;

        if (node?.SpanStart is not int start || node.SpanEnd is not int end)
        {
            return false;
        }

        if (end < start)
        {
            return false;
        }

        spanStart = start;
        spanEnd = end;
        return true;
    }

    private static (int Start, int End)? ResolveParseTreeSpan(ParseTreeNode node)
    {
        if (node is TerminalNode terminalNode)
        {
            var spanStart = Math.Max(0, terminalNode.Token.Position);
            var tokenLength = terminalNode.Token.Length;
            if (tokenLength <= 0)
            {
                tokenLength = terminalNode.Token.OriginalString?.Length ?? 0;
            }

            var spanEnd = spanStart + Math.Max(0, tokenLength);
            return (spanStart, spanEnd);
        }

        return MergeSpans(node.Children.Select(ResolveParseTreeSpan));
    }

    private static (int Start, int End)? ResolveAstNodeSpan(IAstNode node)
    {
        if (node is AstTokenNode tokenNode)
        {
            var spanStart = Math.Max(0, tokenNode.Token.Position);
            var tokenLength = tokenNode.Token.Length;
            if (tokenLength <= 0)
            {
                tokenLength = tokenNode.Text?.Length ?? 0;
            }

            var spanEnd = spanStart + Math.Max(0, tokenLength);
            return (spanStart, spanEnd);
        }

        if (node is AstNodeBase astNodeBase)
        {
            var parseSpan = ResolveParseTreeSpan(astNodeBase.ParseNode);
            if (parseSpan != null)
            {
                return parseSpan;
            }
        }

        return MergeSpans(node.Children.Select(ResolveAstNodeSpan));
    }

    private static (int Start, int End)? MergeSpans(IEnumerable<(int Start, int End)?> spans)
    {
        var hasSpan = false;
        var minStart = int.MaxValue;
        var maxEnd = int.MinValue;

        foreach (var span in spans)
        {
            if (span == null)
            {
                continue;
            }

            hasSpan = true;
            if (span.Value.Start < minStart)
            {
                minStart = span.Value.Start;
            }

            if (span.Value.End > maxEnd)
            {
                maxEnd = span.Value.End;
            }
        }

        return hasSpan ? (minStart, maxEnd) : null;
    }

    private static string? BuildSourcePreview(string source, (int Start, int End)? span)
    {
        if (string.IsNullOrEmpty(source) || span == null)
        {
            return null;
        }

        var safeStart = Math.Clamp(span.Value.Start, 0, source.Length);
        var safeEnd = Math.Clamp(span.Value.End, safeStart, source.Length);
        if (safeEnd <= safeStart)
        {
            return null;
        }

        const int maxSliceLength = 240;
        var sliceLength = Math.Min(safeEnd - safeStart, maxSliceLength);
        var slice = source.Substring(safeStart, sliceLength)
            .Replace("\r\n", "\n")
            .Replace('\r', '\n');

        var previewLines = slice.Split('\n').Take(2).ToArray();
        var preview = string.Join('\n', previewLines);

        if (slice.Length > preview.Length || safeEnd - safeStart > maxSliceLength)
        {
            preview += " ...";
        }

        return preview;
    }
}
